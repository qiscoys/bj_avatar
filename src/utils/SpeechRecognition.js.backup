/**
 * è¯­éŸ³è¯†åˆ«å·¥å…· - ä½¿ç”¨RecorderManageré‡æ„ç‰ˆ
 * åŸºäºç§‘å¤§è®¯é£ WebSocket API + RecorderManager
 * æ”¯æŒæŒç»­è¯†åˆ«å’Œè‡ªåŠ¨é‡è¿
 * 
 * æ³¨æ„ï¼šé€‚é…ä»£ç†æœåŠ¡å™¨ï¼Œä»£ç†æœåŠ¡å™¨ä¼šè‡ªåŠ¨å‘é€é¦–å¸§å‚æ•°
 */

export class VoiceRecognizer {
  constructor() {
    this.ws = null;
    this.listeners = new Map();
    this.isReady = false;
    this.isListening = false;
    this.result = {
      final: '',
      interim: '',
      confidence: 0,
      alternatives: [],
    };
    this.wsUrl = 'ws://localhost:3001/asr';
    this.isConnected = false;
    this.isSpeaking = false;

    // è¯†åˆ«ç»“æœç¼“å­˜
    this.resultText = '';
    this.resultTextTemp = '';
    this.lastNonPunctText = '';
    this.isFirstFrame = false;

    // åˆ†æ®µæ§åˆ¶
    this.segmentResetGapMs = 2000;
    this.lastResultTs = 0;

    // RecorderManagerå®ä¾‹
    this.recorder = null;

    // VAD (è¯­éŸ³æ´»åŠ¨æ£€æµ‹) ç›¸å…³
    this.silenceThreshold = 0.04;
    this.silenceDuration = 1500;
    this.lastSpeechTime = 0;
    this.silenceTimer = null;
    this.minSpeechDuration = 500;
    this.speechStartTime = 0;
    this.isSpeechDetected = false;
    this.waitingForFinalResult = false;
    this.finalResultTimeout = null;

    // æ˜¯å¦å¯ç”¨æ§åˆ¶å°æ—¥å¿—
    this.enableConsoleLog = true;

    // ğŸ”¥ æ–°å¢:è¿ç»­è¯†åˆ«æ§åˆ¶
    this.continuousMode = true; // é»˜è®¤å¼€å¯è¿ç»­è¯†åˆ«
    this.autoReconnect = true;  // è‡ªåŠ¨é‡è¿
    this.isStreamingActive = false; // æ ‡è®°éŸ³é¢‘æµæ˜¯å¦æ´»è·ƒ
    
    // ğŸ”¥ æ–°å¢:é¦–å¸§æ˜¯å¦å·²å‘é€æ ‡å¿—
    this.hasFirstFrameSent = false;
    
    // ğŸ”¥ æ–°å¢:è¿æ¥çŠ¶æ€æ§åˆ¶
    this.isRecorderRunning = false; // å½•éŸ³æ˜¯å¦æ­£åœ¨è¿è¡Œ
    this.isReconnecting = false; // æ˜¯å¦æ­£åœ¨é‡è¿
    
    // ğŸ”¥ æ–°å¢:ä»£ç†æœåŠ¡å™¨æ¨¡å¼ï¼ˆä»£ç†æœåŠ¡å™¨ä¼šè‡ªåŠ¨å‘é€é¦–å¸§å‚æ•°ï¼‰
    this.useProxyServer = true; // é»˜è®¤ä½¿ç”¨ä»£ç†æœåŠ¡å™¨
    
    // ğŸ”¥ æ–°å¢:é‡è¿å»¶è¿Ÿå®šæ—¶å™¨
    this.reconnectTimer = null;
  }

  async init(config = {}) {
    try {
      // æ£€æŸ¥RecorderManageræ˜¯å¦å¯ç”¨
      if (typeof window.RecorderManager === 'undefined') {
        throw new Error('RecorderManageræœªåŠ è½½,è¯·ç¡®ä¿å·²å¼•å…¥ç›¸å…³è„šæœ¬æ–‡ä»¶');
      }

      // åˆå§‹åŒ–RecorderManager
      this.recorder = new window.RecorderManager('/recorder');
      
      // è®¾ç½®å½•éŸ³å›è°ƒ
      this._setupRecorderCallbacks();

      this.isReady = true;
      return true;
    } catch (error) {
      throw error;
    }
  }

  async start(options = {}) {
    if (!this.isReady) {
      await this.init(options);
    }

    if (this.isListening) {
      // å¦‚æœå·²ç»åœ¨ç›‘å¬,å…ˆåœæ­¢
      await this.stop();
    }

    // é‡ç½®ç»“æœ
    this._resetResult();

    // æ ‡è®°çŠ¶æ€
    this.isListening = true;
    this.isStreamingActive = true;
    this.isFirstFrame = true;
    this.hasFirstFrameSent = false;
    this.isReconnecting = false;

    try {
      // ğŸ”¥ å…ˆå¯åŠ¨å½•éŸ³ï¼ˆæŒç»­è¿è¡Œï¼‰
      await this._startRecording();
      
      // ğŸ”¥ ç„¶åè¿æ¥WebSocket
      await this._ensureWebSocketConnection();

      this._emit('start');
    } catch (error) {
      this.isListening = false;
      this.isStreamingActive = false;
      
      // åœæ­¢å½•éŸ³
      if (this.recorder) {
        try {
          this.recorder.stop();
        } catch (e) { /* ignore */ }
      }
      
      throw error;
    }
  }

  async stop() {
    this.isListening = false;
    this.isStreamingActive = false;
    this.isFirstFrame = false;
    this.hasFirstFrameSent = false;
    this.isReconnecting = false;

    // æ¸…ç†é‡è¿å®šæ—¶å™¨
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    // æ¸…ç† VAD å®šæ—¶å™¨
    if (this.silenceTimer) {
      clearTimeout(this.silenceTimer);
      this.silenceTimer = null;
    }

    if (this.finalResultTimeout) {
      clearTimeout(this.finalResultTimeout);
      this.finalResultTimeout = null;
    }

    this.waitingForFinalResult = false;

    // ğŸ”¥ å‘é€ç»“æŸå¸§
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      try {
        this.ws.send(JSON.stringify({
          data: {
            status: 2,
            format: 'audio/L16;rate=16000',
            encoding: 'raw',
            audio: ''
          }
        }));

        // å»¶è¿Ÿå…³é—­,ç¡®ä¿ç»“æŸå¸§å‘é€å®Œæˆ
        setTimeout(() => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.close();
          }
        }, 100);
      } catch (e) {
        if (this.enableConsoleLog) {
          console.warn('[è¯­éŸ³è¯†åˆ«] å‘é€ç»“æŸå¸§å¤±è´¥:', e);
        }
      }
    }

    // åœæ­¢å½•éŸ³
    if (this.recorder) {
      try {
        this.recorder.stop();
        this.isRecorderRunning = false;
      } catch (e) {
        if (this.enableConsoleLog) {
          console.warn('[è¯­éŸ³è¯†åˆ«] åœæ­¢å½•éŸ³å¤±è´¥:', e);
        }
      }
    }

    // é‡ç½®è¯†åˆ«ç»“æœ
    this.resultText = '';
    this.resultTextTemp = '';
    this.lastNonPunctText = '';
    this.lastResultTs = 0;

    this._emit('end');
  }

  async abort() {
    this.isListening = false;
    this.isStreamingActive = false;
    this.hasFirstFrameSent = false;
    this.isReconnecting = false;

    // æ¸…ç†é‡è¿å®šæ—¶å™¨
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    // æ¸…ç† VAD å®šæ—¶å™¨
    if (this.silenceTimer) {
      clearTimeout(this.silenceTimer);
      this.silenceTimer = null;
    }

    if (this.finalResultTimeout) {
      clearTimeout(this.finalResultTimeout);
      this.finalResultTimeout = null;
    }

    this.waitingForFinalResult = false;

    // åœæ­¢å½•éŸ³
    if (this.recorder) {
      try {
        this.recorder.stop();
        this.isRecorderRunning = false;
      } catch (e) { /* ignore */ }
    }

    // å…³é—­ WebSocket
    if (this.ws) {
      try {
        this.ws.close();
      } catch (e) { /* ignore */ }
      this.ws = null;
    }

    // é‡ç½® VAD çŠ¶æ€
    this.isSpeechDetected = false;
    this.speechStartTime = 0;
    this.lastSpeechTime = 0;
  }

  getResult() {
    return {
      final: this.result.final,
      interim: this.result.interim,
      confidence: this.result.confidence,
      alternatives: this.result.alternatives,
    };
  }

  getState() {
    return {
      isReady: this.isReady,
      isListening: this.isListening,
      isConnected: this.isConnected,
      isSpeaking: this.isSpeaking,
      result: { ...this.result }
    };
  }

  isSupported() {
    return typeof window.RecorderManager !== 'undefined';
  }

  /**
   * å¯ç”¨æˆ–ç¦ç”¨æ§åˆ¶å°æ—¥å¿—è¾“å‡º
   * @param {boolean} enabled - true å¯ç”¨,false ç¦ç”¨
   */
  setConsoleLog(enabled) {
    this.enableConsoleLog = enabled;
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);
  }

  off(event, callback) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).delete(callback);
    }
  }

  async destroy() {
    await this.abort();
    this.listeners.clear();
    this.isReady = false;
  }

  /**
   * ğŸ”¥ ç¡®ä¿WebSocketè¿æ¥å¯ç”¨
   */
  async _ensureWebSocketConnection() {
    // æ£€æŸ¥ WebSocket çŠ¶æ€
    const needNewConnection = !this.ws ||
      this.ws.readyState === WebSocket.CLOSED ||
      this.ws.readyState === WebSocket.CLOSING;

    if (needNewConnection) {
      // å…ˆå…³é—­æ—§è¿æ¥
      if (this.ws) {
        try {
          this.ws.close();
        } catch (e) { /* ignore */ }
        this.ws = null;
      }
      await this._connectWebSocket();
    } else if (this.ws.readyState === WebSocket.CONNECTING) {
      // å¦‚æœæ­£åœ¨è¿æ¥,ç­‰å¾…è¿æ¥å®Œæˆ
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('WebSocketè¿æ¥è¶…æ—¶'));
        }, 5000);

        const checkConnection = () => {
          if (this.ws.readyState === WebSocket.OPEN) {
            clearTimeout(timeout);
            if (this.enableConsoleLog) {
              console.log('[è¯­éŸ³è¯†åˆ«] WebSocketè¿æ¥å®Œæˆ');
            }
            resolve();
          } else if (this.ws.readyState === WebSocket.CLOSED || this.ws.readyState === WebSocket.CLOSING) {
            clearTimeout(timeout);
            reject(new Error('WebSocketè¿æ¥å¤±è´¥'));
          } else {
            setTimeout(checkConnection, 100);
          }
        };
        checkConnection();
      });
    }
  }

  /**
   * è®¾ç½®RecorderManagerå›è°ƒ
   */
  _setupRecorderCallbacks() {
    // å½•éŸ³å¼€å§‹å›è°ƒ
    this.recorder.onStart = () => {
      this.isRecorderRunning = true;
      if (this.enableConsoleLog) {
        console.log('[è¯­éŸ³è¯†åˆ«] å½•éŸ³å¼€å§‹');
      }
    };

    // ğŸ”¥ å½•éŸ³æ•°æ®å›è°ƒ - å…³é”®ä¿®æ”¹
    this.recorder.onFrameRecorded = ({ frameBuffer, isLastFrame }) => {
      if (!this.isListening) return;

      // ğŸ”¥ å¦‚æœæ­£åœ¨ç­‰å¾…æœ€ç»ˆç»“æœ,è·³è¿‡å¤„ç†
      if (this.waitingForFinalResult) {
        return;
      }

      // ğŸ”¥ å¦‚æœæ­£åœ¨é‡è¿,è·³è¿‡å¤„ç†ï¼ˆç­‰å¾…é‡è¿å®Œæˆï¼‰
      if (this.isReconnecting) {
        return;
      }

      // VADæ£€æµ‹
      this._performVAD(frameBuffer);

      // ğŸ”¥ å¦‚æœWebSocketæœªè¿æ¥,ä¸å‘é€æ•°æ®
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        return;
      }

      // ğŸ”¥ é™éŸ³é—¨æ§ï¼šä»…åœ¨æ£€æµ‹åˆ°è¯­éŸ³æ´»åŠ¨æ—¶å‘é€éŸ³é¢‘å¸§ï¼Œé™ä½èƒŒæ™¯å™ªå£°å½±å“
      if (!this.isSpeechDetected) {
        return;
      }

      try {
        // ğŸ”¥ å…³é”®ä¿®å¤:ä»£ç†æœåŠ¡å™¨æ¨¡å¼ä¸‹,ä¸éœ€è¦å‘é€é¦–å¸§å‚æ•°
        // ä»£ç†æœåŠ¡å™¨ä¼šåœ¨è¿æ¥å»ºç«‹æ—¶è‡ªåŠ¨å‘é€
        if (this.isFirstFrame && !this.hasFirstFrameSent) {
          // ç›´æ¥å‘é€ç¬¬ä¸€å¸§éŸ³é¢‘æ•°æ®
          this.ws.send(JSON.stringify({
            data: {
              status: 1, // ç¬¬ä¸€å¸§éŸ³é¢‘ä¹Ÿä½¿ç”¨ status: 1
              format: 'audio/L16;rate=16000',
              encoding: 'raw',
              audio: this._arrayBufferToBase64(frameBuffer)
            }
          }));

          this.hasFirstFrameSent = true;
          this.isFirstFrame = false;
        } else {
          // åç»­å¸§
          const status = isLastFrame ? 2 : 1;

          this.ws.send(JSON.stringify({
            data: {
              status,
              format: 'audio/L16;rate=16000',
              encoding: 'raw',
              audio: this._arrayBufferToBase64(frameBuffer)
            }
          }));
        }
      } catch (e) {
        if (this.enableConsoleLog) {
          console.warn('[è¯­éŸ³è¯†åˆ«] å‘é€éŸ³é¢‘æ•°æ®å¤±è´¥:', e);
        }
      }
    };

    // å½•éŸ³åœæ­¢å›è°ƒ
    this.recorder.onStop = () => {
      this.isRecorderRunning = false;
      if (this.enableConsoleLog) {
        console.log('[è¯­éŸ³è¯†åˆ«] å½•éŸ³åœæ­¢');
      }
    };
  }

  /**
   * å¯åŠ¨å½•éŸ³
   */
  async _startRecording() {
    if (!this.recorder) {
      throw new Error('RecorderManageræœªåˆå§‹åŒ–');
    }

    // å¦‚æœå·²ç»åœ¨è¿è¡Œ,ä¸é‡å¤å¯åŠ¨
    if (this.isRecorderRunning) {
      if (this.enableConsoleLog) {
        console.log('[è¯­éŸ³è¯†åˆ«] å½•éŸ³å·²åœ¨è¿è¡Œ,è·³è¿‡å¯åŠ¨');
      }
      return;
    }

    try {
      await this.recorder.start({
        sampleRate: 16000,
        frameSize: 1280,
        arrayBufferType: 'short16'
      });
    } catch (error) {
      throw new Error(`å¯åŠ¨å½•éŸ³å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * VADè¯­éŸ³æ´»åŠ¨æ£€æµ‹
   * @param {ArrayBuffer} frameBuffer - éŸ³é¢‘å¸§æ•°æ®
   */
  _performVAD(frameBuffer) {
    // å°†ArrayBufferè½¬æ¢ä¸ºFloat32Arrayè¿›è¡ŒVADåˆ†æ
    const int16Array = new Int16Array(frameBuffer);
    const floatArray = new Float32Array(int16Array.length);

    // è½¬æ¢ä¸ºæµ®ç‚¹æ•°å¹¶è®¡ç®—éŸ³é‡
    let sum = 0;
    for (let i = 0; i < int16Array.length; i++) {
      floatArray[i] = int16Array[i] / 32768.0;
      sum += Math.abs(floatArray[i]);
    }

    const avgVolume = sum / floatArray.length;
    const isSpeaking = avgVolume > this.silenceThreshold;
    const now = Date.now();

    if (isSpeaking) {
      // æ£€æµ‹åˆ°è¯´è¯
      this.lastSpeechTime = now;

      if (!this.isSpeechDetected) {
        // è¯´è¯å¼€å§‹
        this.isSpeechDetected = true;
        this.speechStartTime = now;
      }

      // æ¸…é™¤é™éŸ³å®šæ—¶å™¨
      if (this.silenceTimer) {
        clearTimeout(this.silenceTimer);
        this.silenceTimer = null;
      }
    } else if (this.isSpeechDetected) {
      // æ£€æµ‹åˆ°é™éŸ³
      if (!this.silenceTimer) {
        this.silenceTimer = setTimeout(() => {
          const speechDuration = this.lastSpeechTime - this.speechStartTime;

          // åªæœ‰è¯´è¯æ—¶é•¿è¶…è¿‡æœ€å°æ—¶é•¿æ‰å‘é€ç»“æŸå¸§
          if (speechDuration >= this.minSpeechDuration) {
            this._sendEndFrame();
          }

          this.isSpeechDetected = false;
          this.silenceTimer = null;
        }, this.silenceDuration);
      }
    }
  }

  async _connectWebSocket() {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(this.wsUrl);

      this.ws.onopen = () => {
        this.isConnected = true;
        this.isReconnecting = false;
        if (this.enableConsoleLog) {
          console.log('[è¯­éŸ³è¯†åˆ«] WebSocketè¿æ¥æˆåŠŸ');
        }
        this._emit('connected');

        // ğŸ”¥ ä»£ç†æœåŠ¡å™¨æ¨¡å¼ä¸‹,ä¸éœ€è¦å®¢æˆ·ç«¯å‘é€é¦–å¸§å‚æ•°
        // ä»£ç†æœåŠ¡å™¨ä¼šè‡ªåŠ¨å‘é€,è¿™é‡Œç›´æ¥ resolve
        resolve();
      };

      this.ws.onmessage = async (event) => {
        try {
          let data = event.data;

          if (data instanceof Blob) {
            data = await data.text();
          }

          const response = JSON.parse(data);
          this._handleWebSocketMessage(response);
        } catch (error) {
          if (this.enableConsoleLog) {
            console.error('[è¯­éŸ³è¯†åˆ«] å¤„ç†æ¶ˆæ¯å¤±è´¥:', error);
          }
        }
      };

      this.ws.onerror = (error) => {
        this.isConnected = false;

        const errorObj = new Error('WebSocketè¿æ¥é”™è¯¯');
        this._emit('error', { error: errorObj });

        reject(error);
      };

      this.ws.onclose = (event) => {
        this.isConnected = false;

        if (this.enableConsoleLog) {
          console.log(`[è¯­éŸ³è¯†åˆ«] WebSocketè¿æ¥å…³é—­: ${event.code} ${event.reason}`);
        }

        this._emit('disconnected');
        
        // é‡ç½®ç­‰å¾…/é¦–å¸§æ ‡å¿—ï¼Œç¡®ä¿é‡è¿åèƒ½å¤Ÿæ­£ç¡®å‘é€é¦–å¸§
        this.waitingForFinalResult = false;
        this.isFirstFrame = true;
        this.hasFirstFrameSent = false;

        // æ¸…ç†å·²æœ‰çš„é‡è¿å®šæ—¶å™¨
        if (this.reconnectTimer) {
          clearTimeout(this.reconnectTimer);
          this.reconnectTimer = null;
        }

        // å¦‚æœä»åœ¨ç›‘å¬ï¼Œå¹¶ä¸”å…è®¸è¿ç»­è¯†åˆ«/è‡ªåŠ¨é‡è¿ï¼Œåˆ™å°è¯•é‡è¿
        if (this.isListening && (this.continuousMode || this.autoReconnect)) {
          this.isReconnecting = true;

          // 1005 å¸¸è§äºæœåŠ¡ç«¯å¼‚å¸¸å…³é—­ï¼Œç¨åŠ å»¶è¿Ÿå†é‡è¿
          const initialDelay = event.code === 1005 ? 500 : 200;
          if (this.enableConsoleLog) {
            console.log(`[è¯­éŸ³è¯†åˆ«] ${initialDelay}ms åå°è¯•é‡è¿`);
          }

          this.reconnectTimer = setTimeout(async () => {
            try {
              await this._ensureWebSocketConnection();
              this.isReconnecting = false;
              if (this.enableConsoleLog) {
                console.log('[è¯­éŸ³è¯†åˆ«] é‡è¿æˆåŠŸ');
              }
            } catch (error) {
              this.isReconnecting = false;
              if (this.enableConsoleLog) {
                console.error('[è¯­éŸ³è¯†åˆ«] é‡è¿å¤±è´¥:', error);
              }
              // ç®€å•çš„äºŒæ¬¡é‡è¯•ï¼Œé¿å…é™·å…¥æ— ç©·å¾ªç¯
              const nextDelay = Math.min(initialDelay * 2, 5000);
              if (this.isListening) {
                if (this.enableConsoleLog) {
                  console.log(`[è¯­éŸ³è¯†åˆ«] ${nextDelay}ms åå†æ¬¡å°è¯•é‡è¿`);
                }
                this.reconnectTimer = setTimeout(async () => {
                  try {
                    await this._ensureWebSocketConnection();
                    this.isReconnecting = false;
                    if (this.enableConsoleLog) {
                      console.log('[è¯­éŸ³è¯†åˆ«] é‡è¿æˆåŠŸ');
                    }
                  } catch (e2) {
                    if (this.enableConsoleLog) {
                      console.error('[è¯­éŸ³è¯†åˆ«] é‡è¿å†æ¬¡å¤±è´¥:', e2);
                    }
                    this.isReconnecting = false;
                  }
                }, nextDelay);
              }
            }
          }, initialDelay);
        } else {
          // éè¿ç»­æ¨¡å¼æˆ–æœªåœ¨ç›‘å¬ï¼Œè§¦å‘ç»“æŸäº‹ä»¶
          const result = this.getResult();
          this._emit('end', result);
        }

        // æ¸…ç©º ws å¼•ç”¨
        this.ws = null;
      };
    });
  }

  _handleWebSocketMessage(response) {
    if (response.error) {
      const error = new Error(`è¯­éŸ³è¯†åˆ«é”™è¯¯: ${response.error}`);
      this._emit('error', { error });
      return;
    }

    if (!response.data) {
      return;
    }

    const { data } = response;

    if (data.result) {
      const nowTs = Date.now();

      if (this.lastResultTs && (nowTs - this.lastResultTs > this.segmentResetGapMs)) {
        this.resultText = '';
        this.resultTextTemp = '';
        this.lastNonPunctText = '';
      }

      const result = data.result;
      const ws = result.ws || [];
      let str = '';

      for (let i = 0; i < ws.length; i++) {
        if (ws[i].cw && ws[i].cw[0] && ws[i].cw[0].w) {
          str += ws[i].cw[0].w;
        }
      }

      if (!this.resultText) this.resultText = '';
      if (!this.resultTextTemp) this.resultTextTemp = '';

      if (result.pgs) {
        if (result.pgs === 'apd') {
          this.resultText = this.resultTextTemp;
        }
        this.resultTextTemp = this.resultText + str;
      } else {
        this.resultText += str;
      }

      const currentText = (this.resultTextTemp || this.resultText || '').trim();
      const punctOnlyRegex = /^[\s.,!?;:â€¦,ã€‚?!;:""-]*$/;

      let effectiveText = currentText;
      const isFinalStatus = data.status === 2;
      // è¿‡æ»¤çº¯è¯­æ°”è¯ï¼ˆå—¯/å‘ƒ/å•Š/å“¦/å””/è¯¶/å“/å“‡/å“¼/å’¦ ç­‰ï¼‰
      const isFillerOnly = this._isFillerOnly(effectiveText);

      if (isFinalStatus && (punctOnlyRegex.test(effectiveText) || !effectiveText || isFillerOnly)) {
        const fallback = this.lastNonPunctText || '';
        if (fallback) {
          effectiveText = fallback;
        }
      }

      const hasEffectiveContent = effectiveText && !punctOnlyRegex.test(effectiveText) && !isFillerOnly;

      if (hasEffectiveContent && !isFinalStatus) {
        this.lastNonPunctText = effectiveText;
      }

      if (hasEffectiveContent || (isFinalStatus && this.lastNonPunctText)) {
        if (isFinalStatus) {
          const finalText = hasEffectiveContent ? effectiveText : this.lastNonPunctText;
          this.result.final = finalText;
          this.result.interim = '';

          this._emit('result', {
            final: finalText,
            interim: '',
            isFinal: true,
            confidence: result.confidence || 0,
          });

          this.resultText = '';
          this.resultTextTemp = '';
          this.lastNonPunctText = '';

          // ğŸ”¥ æ”¶åˆ°æœ€ç»ˆç»“æœå,é‡ç½®çŠ¶æ€
          this._resetAfterFinalResult();

          // ğŸ”¥ å¦‚æœæ˜¯è¿ç»­è¯†åˆ«æ¨¡å¼,ç«‹å³é‡è¿ï¼ˆä¸ç­‰å¾…è¯­éŸ³æ´»åŠ¨ï¼‰
          if (this.continuousMode && this.isListening) {
            if (this.enableConsoleLog) {
              console.log('[è¯­éŸ³è¯†åˆ«] æ”¶åˆ°æœ€ç»ˆç»“æœ,å‡†å¤‡é‡è¿');
            }
            
            // ğŸ”¥ å»¶è¿Ÿé‡è¿,é¿å…ç«‹å³é‡è¿å¯¼è‡´çš„é—®é¢˜
            // å…ˆå…³é—­å½“å‰è¿æ¥
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
              try {
                this.ws.close();
              } catch (e) { /* ignore */ }
            }
            
            // ğŸ”¥ å»¶è¿Ÿ 200ms åé‡è¿,ç»™æœåŠ¡ç«¯è¶³å¤Ÿçš„æ—¶é—´å¤„ç†å…³é—­
            this.isReconnecting = true;
            this.reconnectTimer = setTimeout(async () => {
              try {
                if (this.enableConsoleLog) {
                  console.log('[è¯­éŸ³è¯†åˆ«] å¼€å§‹é‡è¿');
                }
                
                // é‡ç½®é¦–å¸§æ ‡è®°
                this.isFirstFrame = true;
                this.hasFirstFrameSent = false;
                
                // é‡æ–°è¿æ¥
                await this._ensureWebSocketConnection();
                
                if (this.enableConsoleLog) {
                  console.log('[è¯­éŸ³è¯†åˆ«] é‡è¿æˆåŠŸ,å‡†å¤‡æ¥æ”¶ä¸‹ä¸€è½®è¯†åˆ«');
                }
              } catch (error) {
                if (this.enableConsoleLog) {
                  console.error('[è¯­éŸ³è¯†åˆ«] é‡è¿å¤±è´¥:', error);
                }
                // é‡è¿å¤±è´¥,æ ‡è®°ä¸ºéé‡è¿çŠ¶æ€,ç­‰å¾…ä¸‹æ¬¡å°è¯•
                this.isReconnecting = false;
              }
            }, 200);
          } else {
            // éè¿ç»­æ¨¡å¼,è°ƒç”¨ stop
            setTimeout(() => {
              this.stop();
            }, 50);
          }
        } else {
          this.result.interim = effectiveText;
          this.result.final = '';

          this._emit('result', {
            final: '',
            interim: effectiveText,
            isFinal: false,
            confidence: result.confidence || 0,
          });
        }

        this.lastResultTs = nowTs;
      }
    }
  }

  /**
   * ArrayBufferè½¬Base64
   */
  _arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  /**
   * æ£€æµ‹æ˜¯å¦ä¸ºçº¯è¯­æ°”è¯ï¼ˆå¡«å……è¯ï¼‰ï¼Œç”¨äºè¿‡æ»¤â€œå—¯å—¯å—¯/å‘ƒå‘ƒâ€ç­‰ä½ä»·å€¼è¯†åˆ«ç»“æœ
   */
  _isFillerOnly(text = '') {
    const t = String(text)
      .replace(/[\s.,!?;:â€¦,ã€‚?!;:""-]/g, '') // å»é™¤ç©ºç™½å’Œæ ‡ç‚¹
      .trim();
    if (!t) return false;
    // å¸¸è§ä¸­æ–‡å£å¤´å¡«å……è¯é›†åˆ
    const fillerRegex = /^[å—¯å‘ƒå•Šå“¦å””è¯¶å–”å“å“‡å“¼å’¦å‘€å“ˆå˜¿å‘µ]+$/;
    return fillerRegex.test(t);
  }

  /**
   * å‘é€ç»“æŸå¸§å¹¶ç­‰å¾…æœ€ç»ˆç»“æœ
   */
  _sendEndFrame() {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

    // å¦‚æœå·²ç»åœ¨ç­‰å¾…æœ€ç»ˆç»“æœ,é¿å…é‡å¤å‘é€
    if (this.waitingForFinalResult) {
      return;
    }

    try {
      // å‘é€ç»“æŸå¸§,è§¦å‘æœåŠ¡å™¨è¿”å›æœ€ç»ˆç»“æœ
      this.ws.send(JSON.stringify({
        data: {
          status: 2,
          format: 'audio/L16;rate=16000',
          encoding: 'raw',
          audio: ''
        }
      }));

      // ğŸ”¥ æ ‡è®°ç­‰å¾…æœ€ç»ˆç»“æœ,æš‚åœ VAD æ£€æµ‹
      this.waitingForFinalResult = true;

      if (this.enableConsoleLog) {
        console.log('[è¯­éŸ³è¯†åˆ«] å‘é€ç»“æŸå¸§,ç­‰å¾…æœ€ç»ˆç»“æœ');
      }

    } catch (e) {
      this.waitingForFinalResult = false;
      if (this.enableConsoleLog) {
        console.warn('[è¯­éŸ³è¯†åˆ«] å‘é€ç»“æŸå¸§å¤±è´¥:', e);
      }
    }
  }

  /**
   * æ”¶åˆ°æœ€ç»ˆç»“æœåé‡ç½®çŠ¶æ€
   */
  _resetAfterFinalResult() {
    // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
    if (this.finalResultTimeout) {
      clearTimeout(this.finalResultTimeout);
      this.finalResultTimeout = null;
    }

    // é‡ç½®ç­‰å¾…æ ‡å¿—
    this.waitingForFinalResult = false;

    // é‡ç½®è¯†åˆ«çŠ¶æ€,å‡†å¤‡ä¸‹ä¸€è½®
    this.isFirstFrame = true;
    this.hasFirstFrameSent = false;
    this.resultText = '';
    this.resultTextTemp = '';
    this.lastNonPunctText = '';

    if (this.enableConsoleLog) {
      console.log('[è¯­éŸ³è¯†åˆ«] çŠ¶æ€å·²é‡ç½®,å‡†å¤‡ä¸‹ä¸€è½®è¯†åˆ«');
    }
  }

  /**
   * é‡ç½®ç»“æœ
   */
  _resetResult() {
    this.result = {
      final: '',
      interim: '',
      confidence: 0,
      alternatives: [],
    };
    this.resultText = '';
    this.resultTextTemp = '';
    this.lastNonPunctText = '';
    this.lastResultTs = 0;

    // é‡ç½® VAD çŠ¶æ€
    this.isSpeechDetected = false;
    this.lastSpeechTime = 0;
    this.speechStartTime = 0;
    this.waitingForFinalResult = false;
    this.hasFirstFrameSent = false;

    if (this.silenceTimer) {
      clearTimeout(this.silenceTimer);
      this.silenceTimer = null;
    }

    if (this.finalResultTimeout) {
      clearTimeout(this.finalResultTimeout);
      this.finalResultTimeout = null;
    }

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * è§¦å‘äº‹ä»¶
   */
  _emit(event, data = {}) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          if (this.enableConsoleLog) {
            console.error(`[è¯­éŸ³è¯†åˆ«] äº‹ä»¶ ${event} å›è°ƒæ‰§è¡Œå¤±è´¥:`, error);
          }
        }
      });
    }
  }
}

export default VoiceRecognizer;