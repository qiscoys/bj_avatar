/**
 * è¯­éŸ³åˆæˆå·¥å…·
 * ç§‘å¤§è®¯é£WebSocketå®ç°
 */

export class VoiceSynthesizer {
  constructor() {
    this.socket = null;
    this.currentAudio = null;
    this.listeners = new Map();
    this.isReady = false;
    this.isPlaying = false;
    this.isPaused = false;
    this.currentText = '';
    this.wsUrl = 'ws://localhost:3001/tts-ws';

    // æµå¼æ’­æ”¾ç›¸å…³
    this.audioContext = null;
    this.gainNode = null;
    this.nextStartTime = 0;
    this.initialBufferSec = 0.2;
    this.streamStarted = false;
    this.streamEnded = false;
    this.streamFinalized = false;
    this.lastSource = null;

    // ç”¨äºç²¾ç¡®è¿½è¸ªéŸ³é¢‘æº
    this.activeSources = new Set();
    this.endTimer = null;
    this.currentOptions = null;

    this.realPlaybackEndTime = 0;  // å®é™…æ’­æ”¾ç»“æŸæ—¶é—´
    this.endCheckInterval = null;   // ç»“æŸæ£€æµ‹å®šæ—¶å™¨
    this.isReallyPlaying = false;
  }

  async init() {
    this.isReady = true;
    return true;
  }

  async speak(text, options = {}) {
    if (!this.isReady) await this.init();

    const {
      onStart = null,
      onStop = null,
      onError = null,
      voiceName = 'x4_yezi', // é»˜è®¤å‘éŸ³äºº
    } = options;

    this.stop();

    const cleanText = this._cleanText(text);
    if (!cleanText.trim()) {
      onStop?.();
      return;
    }

    this.currentText = cleanText;
    this.currentOptions = { onStart, onStop, onError, voiceName };

    try {
      await this._speakWithWebSocket(cleanText, { onStart, onStop, onError, voiceName });
    } catch (error) {
      console.error('è¯­éŸ³åˆæˆé”™è¯¯:', error);
      this._emit('error', { error, text: cleanText });
      onError?.(error);
    }
  }

  async _speakWithWebSocket(text, options = {}) {
    return new Promise((resolve, reject) => {
      // é‡ç½®æ‰€æœ‰çŠ¶æ€
      this._resetStreamState();

      this.socket = new WebSocket(this.wsUrl);
      let audioChunks = [];

      this.socket.onopen = () => {
        // ğŸ”¥ ä½¿ç”¨è½®è¯¢ç­‰å¾… WebSocket å®Œå…¨å°±ç»ª
        const waitForReady = (retries = 0) => {
          if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            try {
              this.socket.send(JSON.stringify({ action: 'connect' }));
            } catch (e) {
              console.error('TTS å‘é€è¿æ¥æ¶ˆæ¯å¤±è´¥:', e);
              reject(e);
            }
          } else if (retries < 10) {
            // æœ€å¤šé‡è¯•10æ¬¡ï¼Œæ¯æ¬¡é—´éš”20msï¼ˆæ€»å…±200msï¼‰
            setTimeout(() => waitForReady(retries + 1), 20);
          } else {
            console.error('TTS WebSocket è¿æ¥è¶…æ—¶ï¼Œå½“å‰çŠ¶æ€:', this.socket?.readyState);
            reject(new Error('WebSocket è¿æ¥è¶…æ—¶'));
          }
        };
        waitForReady();
      };

      this.socket.onmessage = (event) => {
        try {
          let response;
          if (typeof event.data === 'string') {
            response = JSON.parse(event.data);
          } else if (event.data instanceof Blob) {
            const reader = new FileReader();
            reader.onload = () => {
              const audioChunk = new Uint8Array(reader.result);
              audioChunks.push(audioChunk);
            };
            reader.readAsArrayBuffer(event.data);
            return;
          } else {
            return;
          }

          if (response.error) {
            reject(new Error(response.error));
            return;
          }

          if (response.status === 'connected') {
            // ğŸ”¥ ç¡®ä¿ WebSocket çŠ¶æ€å°±ç»ªåå†å‘é€
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
              this._sendTTSRequest(text, options.voiceName);
            } else {
              console.warn('TTS æ”¶åˆ° connected å“åº”ï¼Œä½† socket æœªå°±ç»ª');
            }
            return;
          }

          if (response.status === 'closed') {
            this._handleStreamEnd(audioChunks, options);
            resolve();
            return;
          }

          // å¤„ç†è®¯é£è¿”å›çš„éŸ³é¢‘æ•°æ®
          if (response.type === 'audio' && response.data) {
            const binaryString = atob(response.data);
            const audioChunk = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              audioChunk[i] = binaryString.charCodeAt(i);
            }
            audioChunks.push(audioChunk);
            this._enqueuePcmChunk(audioChunk, options);

            if (response.status === 2) {
              this._handleStreamEnd(audioChunks, options);
              this.socket.close();
              resolve();
            }
            return;
          }

          // å¤„ç†åŸå§‹è®¯é£æ ¼å¼çš„å“åº”
          if (response.code === 0 && response.data && response.data.audio) {
            const binaryString = atob(response.data.audio);
            const audioChunk = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              audioChunk[i] = binaryString.charCodeAt(i);
            }
            audioChunks.push(audioChunk);
            this._enqueuePcmChunk(audioChunk, options);

            if (response.data.status === 2) {
              this._handleStreamEnd(audioChunks, options);
              this.socket.close();
              resolve();
            }
            return;
          }

          if (response.code && response.code !== 0) {
            reject(new Error(response.message || 'åˆæˆå¤±è´¥'));
          }
        } catch (error) {
          reject(error);
        }
      };

      this.socket.onclose = () => {
        this._handleStreamEnd(audioChunks, options);
      };

      this.socket.onerror = (error) => {
        console.error('WebSocketé”™è¯¯:', error);
        reject(new Error('WebSocketè¿æ¥å¤±è´¥'));
      };
    });
  }

  /**
   * å¤„ç†æµç»“æŸ - çº¯æµå¼ç‰ˆ
   */
  _handleStreamEnd(audioChunks, options) {
    this.streamEnded = true;

    if (!this.streamStarted) {
      // æµæœªå¯åŠ¨,ç›´æ¥ç»“æŸ
      this._finalizeStreamPlayback(options);
      return;
    }
  }


  /**
   * è°ƒåº¦æµå¼æ’­æ”¾ç»“æŸ
   */
  _scheduleStreamEnd(options) {
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (this.endTimer) {
      clearTimeout(this.endTimer);
      this.endTimer = null;
    }

    if (!this.audioContext || this.streamFinalized) {
      return;
    }

    // è®¡ç®—å‰©ä½™æ’­æ”¾æ—¶é—´
    const now = this.audioContext.currentTime;
    const remainingTime = Math.max(0, this.nextStartTime - now);

    // æ·»åŠ å°çš„ç¼“å†²æ—¶é—´ï¼ˆ100msï¼‰ç¡®ä¿æœ€åä¸€å¸§æ’­å®Œ
    const delay = (remainingTime + 0.1) * 1000;

    this.endTimer = setTimeout(() => {
      this._finalizeStreamPlayback(options);
      // äºŒæ¬¡ç¡®è®¤ï¼šæ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ´»è·ƒçš„éŸ³é¢‘æº
      // if (this.activeSources.size === 0 && !this.streamFinalized) {
      //   this._finalizeStreamPlayback(options);
      // } else {
      //   // å¦‚æœè¿˜æœ‰æ´»è·ƒæºï¼Œå†ç­‰å¾…ä¸€å°æ®µæ—¶é—´
      //   this.endTimer = setTimeout(() => {
      //     if (!this.streamFinalized) {
      //       this._finalizeStreamPlayback(options);
      //     }
      //   }, 200);
      // }
    }, delay);
  }

  /**
   * æµå¼æ’­æ”¾éŸ³é¢‘å—
   */
  _enqueuePcmChunk(u8pcm, options = {}) {
    try {
      if (!this.audioContext) {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.gainNode = this.audioContext.createGain();
        this.gainNode.gain.value = 1.0;
        this.gainNode.connect(this.audioContext.destination);
        this.nextStartTime = 0;
        this.streamStarted = false;
        this.streamEnded = false;
        this.lastSource = null;
        this.activeSources.clear();
        this.realPlaybackEndTime = 0;
        this.isReallyPlaying = false;
      }
      // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº
      const samples = Math.floor(u8pcm.length / 2);
      const buffer = this.audioContext.createBuffer(1, samples, 16000);
      const channelData = buffer.getChannelData(0);
      const dv = new DataView(u8pcm.buffer, u8pcm.byteOffset, u8pcm.byteLength);
      for (let i = 0; i < samples; i++) {
        const s = dv.getInt16(i * 2, true);
        channelData[i] = s / 32768;
      }
      // åˆ›å»ºéŸ³é¢‘æº
      const src = this.audioContext.createBufferSource();
      src.buffer = buffer;
      src.connect(this.gainNode);

      const now = this.audioContext.currentTime;
      if (!this.streamStarted) {
        this.nextStartTime = Math.max(now + this.initialBufferSec, this.nextStartTime || 0);
        this.streamStarted = true;
        this.isPlaying = true;
        this.isReallyPlaying = true;
        this._emit('start', { text: this.currentText });
        options.onStart?.();

        // å¯åŠ¨å®æ—¶æ’­æ”¾çŠ¶æ€æ£€æµ‹
        this._startPlaybackMonitor();
      } else if (this.nextStartTime < now) {
        this.nextStartTime = now + 0.02;
      }

      this.activeSources.add(src);
      this.lastSource = src;

      src.start(this.nextStartTime);
      this.nextStartTime += buffer.duration;

      // æ›´æ–°é¢„è®¡çš„å®é™…æ’­æ”¾ç»“æŸæ—¶é—´
      this.realPlaybackEndTime = this.nextStartTime;

      // ä¼˜åŒ–çš„ onended å›è°ƒ
      src.onended = () => {
        this.activeSources.delete(src);

        // å…³é”®ä¼˜åŒ–:åªåœ¨ç¡®è®¤æ˜¯æœ€åä¸€ä¸ªsourceæ—¶æ‰è§¦å‘ç»“æŸ
        if (this.streamEnded &&
          this.activeSources.size === 0 &&
          src === this.lastSource) {
          // ç«‹å³è§¦å‘,ä¸å†å»¶è¿Ÿ
          this._tryFinalizeStream(options);
        }
      };
    } catch (e) {
      console.error('æµå¼æ’­æ”¾å¤±è´¥:', e);
    }
  }
  _startPlaybackMonitor() {
    if (this.endCheckInterval) {
      clearInterval(this.endCheckInterval);
    }

    this.endCheckInterval = setInterval(() => {
      if (!this.audioContext || !this.streamStarted) {
        this._stopPlaybackMonitor();
        return;
      }

      const now = this.audioContext.currentTime;

      // æ£€æµ‹:å¦‚æœå½“å‰æ—¶é—´å·²ç»è¶…è¿‡æ‰€æœ‰é¢„å®šæ’­æ”¾æ—¶é—´,è¯´æ˜çœŸçš„æ’­æ”¾å®Œäº†
      if (this.streamEnded && now >= this.realPlaybackEndTime) {
        const isStillActive = this.activeSources.size > 0;

        if (!isStillActive) {
          this.isReallyPlaying = false;
          this._tryFinalizeStream(this.currentOptions);
        }
      }
    }, 50); // æ¯50msæ£€æµ‹ä¸€æ¬¡
  }

  /**
   * åœæ­¢æ’­æ”¾ç›‘æ§
   */
  _stopPlaybackMonitor() {
    if (this.endCheckInterval) {
      clearInterval(this.endCheckInterval);
      this.endCheckInterval = null;
    }
  }

  /**
   * å°è¯•å®Œæˆæµæ’­æ”¾
   */
  _tryFinalizeStream(options) {
    if (this.streamFinalized) return;

    // åŒé‡æ£€æŸ¥:ç¡®ä¿çœŸçš„æ²¡æœ‰æ´»è·ƒçš„sourceäº†
    if (this.activeSources.size > 0) return;

    // ä¸‰é‡æ£€æŸ¥:ç¡®ä¿å½“å‰æ—¶é—´ç¡®å®è¶…è¿‡äº†æ’­æ”¾ç»“æŸæ—¶é—´
    if (this.audioContext) {
      const now = this.audioContext.currentTime;
      if (now < this.realPlaybackEndTime - 0.05) { // ç•™50msè¯¯å·®
        return;
      }
    }

    this._finalizeStreamPlayback(options);
  }

  /**
   * å®Œæˆæµå¼æ’­æ”¾
   */
  _finalizeStreamPlayback(options = {}) {
    if (this.streamFinalized) return;

    this.streamFinalized = true;
    this.isPlaying = false;
    this.isReallyPlaying = false;

    // åœæ­¢ç›‘æ§
    this._stopPlaybackMonitor();

    // æ¸…é™¤å®šæ—¶å™¨
    if (this.endTimer) {
      clearTimeout(this.endTimer);
      this.endTimer = null;
    }

    // ç«‹å³è§¦å‘ç»“æŸäº‹ä»¶
    this._emit('end', { text: this.currentText });
    options.onStop?.();
    this.currentText = '';
  }
  /**
   * é‡ç½®æµçŠ¶æ€
   */
  _resetStreamState() {
    this.streamStarted = false;
    this.streamEnded = false;
    this.streamFinalized = false;
    this.nextStartTime = 0;
    this.lastSource = null;
    this.activeSources.clear();
    this.realPlaybackEndTime = 0;
    this.isReallyPlaying = false;

    this._stopPlaybackMonitor();

    if (this.endTimer) {
      clearTimeout(this.endTimer);
      this.endTimer = null;
    }
  }


  _sendTTSRequest(text, voiceName = 'x4_yezi') {
    if (!text || text.trim() === '') {
      console.error('é”™è¯¯: åˆæˆæ–‡æœ¬ä¸èƒ½ä¸ºç©º');
      return;
    }

    // ğŸ”¥ æ£€æŸ¥ WebSocket çŠ¶æ€ï¼Œç¡®ä¿å·²è¿æ¥
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      console.warn('TTS WebSocket æœªå°±ç»ªï¼Œå½“å‰çŠ¶æ€:', this.socket?.readyState, 'æœŸæœ›çŠ¶æ€:', WebSocket.OPEN);
      return;
    }

    const encodedText = btoa(unescape(encodeURIComponent(text)));

    const fullFrame = {
      common: {
        app_id: '130cba7b'
      },
      business: {
        aue: 'raw',
        auf: 'audio/L16;rate=16000',
        vcn: voiceName, // ä½¿ç”¨ä¼ å…¥çš„å‘éŸ³äººå‚æ•°
        speed: 70,
        volume: 50,
        pitch: 50,
        tte: 'utf8',
        sfl: 1
      },
      data: {
        status: 2,
        text: encodedText
      }
    };

    try {
      this.socket.send(JSON.stringify(fullFrame));
    } catch (e) {
      console.error('TTS å‘é€è¯·æ±‚å¤±è´¥:', e);
    }
  }

  _playAudioChunks(audioChunks, options = {}) {
    if (!audioChunks || audioChunks.length === 0) {
      options.onStop?.();
      return;
    }

    let totalLength = 0;
    audioChunks.forEach(chunk => {
      totalLength += chunk.length;
    });

    const mergedAudio = new Uint8Array(totalLength);
    let offset = 0;
    audioChunks.forEach(chunk => {
      mergedAudio.set(chunk, offset);
      offset += chunk.length;
    });

    const wavHeader = this._createWavHeader(mergedAudio.length);
    const wavData = new Uint8Array(wavHeader.length + mergedAudio.length);
    wavData.set(wavHeader, 0);
    wavData.set(mergedAudio, wavHeader.length);

    const audioBlob = new Blob([wavData], { type: 'audio/wav' });
    const audioUrl = URL.createObjectURL(audioBlob);

    this.currentAudio = new Audio(audioUrl);
    this.currentAudio.volume = 1.0;
    this.currentAudio.preload = 'auto';

    this.currentAudio.onloadeddata = () => {
      this.isPlaying = true;
      this._emit('start', { text: this.currentText });
      options.onStart?.();

      this.currentAudio.play().catch(error => {
        console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
        this.isPlaying = false;
        this._emit('error', { error, text: this.currentText });
        options.onError?.(error);
      });
    };

    this.currentAudio.onended = () => {
      this.isPlaying = false;
      const text = this.currentText;
      this.currentText = '';
      this._emit('end', { text });
      options.onStop?.();
      URL.revokeObjectURL(audioUrl);
    };

    this.currentAudio.onerror = (error) => {
      this.isPlaying = false;
      this.currentText = '';
      this._emit('error', { error, text: this.currentText });
      options.onError?.(error);
      URL.revokeObjectURL(audioUrl);
    };
  }

  _createWavHeader(dataLength) {
    const sampleRate = 16000;
    const numChannels = 1;
    const bitsPerSample = 16;
    const byteRate = sampleRate * numChannels * bitsPerSample / 8;
    const blockAlign = numChannels * bitsPerSample / 8;
    const totalLength = dataLength + 44;

    const header = new ArrayBuffer(44);
    const view = new DataView(header);

    view.setUint32(0, 0x52494646, false); // "RIFF"
    view.setUint32(4, totalLength - 8, true);
    view.setUint32(8, 0x57415645, false); // "WAVE"
    view.setUint32(12, 0x666d7420, false); // "fmt "
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitsPerSample, true);
    view.setUint32(36, 0x64617461, false); // "data"
    view.setUint32(40, dataLength, true);

    return new Uint8Array(header);
  }

  stop() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.close();
    }

    if (this.isPlaying && this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio.currentTime = 0;
      this.currentAudio = null;
      this.isPlaying = false;
      this.currentText = '';
    }

    // åœæ­¢ç›‘æ§
    this._stopPlaybackMonitor();

    // æ¸…ç†å®šæ—¶å™¨
    if (this.endTimer) {
      clearTimeout(this.endTimer);
      this.endTimer = null;
    }

    // åœæ­¢æµå¼æ’­æ”¾
    if (this.audioContext) {
      this.activeSources.forEach(src => {
        try { src.stop(); } catch { }
      });
      this.activeSources.clear();

      try { this.gainNode?.disconnect(); } catch { }
      try { this.audioContext.close(); } catch { }
      this.audioContext = null;
      this.gainNode = null;
      this._resetStreamState();
    }
  }
  isActuallyPlaying() {
    if (!this.audioContext || !this.streamStarted) return false;

    const now = this.audioContext.currentTime;
    return this.isReallyPlaying &&
      this.activeSources.size > 0 &&
      now < this.realPlaybackEndTime;
  }
  pause() {
    if (this.isPlaying && this.currentAudio && !this.currentAudio.paused) {
      this.currentAudio.pause();
      this.isPaused = true;
    }
  }

  resume() {
    if (this.currentAudio && this.currentAudio.paused && this.isPaused) {
      this.currentAudio.play();
      this.isPaused = false;
    }
  }

  getVoices() {
    return [
      { name: 'x4_xiaoyan', lang: 'zh-CN', localService: false, voiceURI: 'x4_xiaoyan' },
      { name: 'x4_xiaofeng', lang: 'zh-CN', localService: false, voiceURI: 'x4_xiaofeng' },
      { name: 'x4_xiaoqian', lang: 'zh-CN', localService: false, voiceURI: 'x4_xiaoqian' }
    ];
  }

  getState() {
    return {
      speaking: this.isPlaying,
      paused: this.isPaused,
      pending: false,
      isReady: this.isReady,
      voicesCount: this.getVoices().length,
    };
  }

  isSupported() {
    return typeof WebSocket !== 'undefined';
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  off(event, callback) {
    if (!this.listeners.has(event)) return;
    const callbacks = this.listeners.get(event);
    const index = callbacks.indexOf(callback);
    if (index > -1) callbacks.splice(index, 1);
  }

  destroy() {
    this.stop();
    this.listeners.clear();
    this.isReady = false;
    this.currentOptions = null;
  }

  _cleanText(html) {
    if (typeof html !== 'string') return '';
    const text = html.replace(/<[^>]*>/g, '');
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value.trim();
  }

  _emit(event, data) {
    if (!this.listeners.has(event)) return;
    this.listeners.get(event).forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in ${event} listener:`, error);
      }
    });
  }
}

export default VoiceSynthesizer;
